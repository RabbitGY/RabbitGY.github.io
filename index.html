<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="代码、思考、生活" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     RabbitGY
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/images/gy.png" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="RabbitGY" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/earth.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">RabbitGY</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-数据结构与算法-一"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%80/"
    >数据结构与算法(一)</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%80/" class="article-date">
  <time datetime="2020-06-16T13:21:57.000Z" itemprop="datePublished">2020-06-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="为什么要学数据结构与算法？"><a href="#为什么要学数据结构与算法？" class="headerlink" title="为什么要学数据结构与算法？"></a>为什么要学数据结构与算法？</h3><p>在工作中，我们总是喜欢高谈阔论，谈论高性能、高可用、微服务等，很少有人能潜心钻研基础知识，提升自己代码层面的编程能力。数据结构是一组数据的存储结构，算法是操作数据的方法，简单的说，数据结构是为算法服务的，算法是要作用在特定的数据结构上的。数据结构与算法就像是一座大厦的地基，地基够“坚实”，我们的技术高度才能达到更高。无论你是想在工作中更进一步，还是想寻一份更好的工作，数据结构和算法都是你必修的“内功”。接下来我会根据自己所学加以自己的理解，挑选以下的内容由浅入深地带你进入数据结构与算法的世界。</p>
<blockquote>
<p><strong>8 个数据结构</strong>：数组、链表、栈、队列、散列表、树(二叉树、堆、多路查找树、Trie树)、跳表、图<br><strong>10 个算法</strong>：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</p>
</blockquote>
<p>那有人说了，这些内容在书上都可以学习到啊，你这个有什么优势呢？</p>
<p>不错，诸如像《算法导论》这些经典书籍，全面却枯燥乏味，脱离实际。而在这里，我会探究它们的定义、特征、适用问题以及实际场景等等，带你一步一步地掌握它们，简洁又高效。</p>
<p>好，话不多说，直入主题！</p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>几乎每一种语言，都会有数组这种数据结构。大家应该或多或少都用过数组，这是一种最基础的数据结构，那么让我们来一探究竟。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>数组</strong>（Array），是一种线性表数据结构。使用一块连续的内存空间，来存储一组具有相同类型的数据。</p>
<blockquote>
<p><strong>线性表</strong>：是n个具有相同特性的数据元素的有限序列，就像线一样，数据之间是简单的前后关系，包括数组、链表、队列、栈等等。<br><strong>非线性表</strong>：数据之间并不是简单的前后关系，比如二叉树、堆、图等。</p>
</blockquote>
<blockquote>
<p><strong>连续的内存空间和相同类型的数据</strong>。正因为数组有这两个限制，所以具备了“随机访问”的逆天特性，可以根据下标访问任意位置的元素。但要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
</blockquote>
<h4 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h4><p><strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong></p>
<p>假设有一个数组，长度为10，即int[] a = new int[10] ，计算机会给其分配了一块连续的内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。<br><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee95770.png" alt=""><br>那么数组是如何实现根据下标随机访问数组元素的呢？众所周知，每个内存单元都会被计算机分配一个地址，而数组元素的地址是连续的，计算机可以通过地址来访问内存中的数据。当我们需要随机访问某个元素时，其实是通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure>
<p>其中 data_type_size 表示数组中每个元素的大小,数组a中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。知道了随机访问的原理，那就衍生出了一个问题：</p>
<blockquote>
<p><strong>为什么数组要从 0 开始编号，而不是从 1 开始呢？</strong><br>根据以上的讲解，我们知道数组的寻址公式是<br><code>a[k]_address = base_address + k * type_size</code><br>获取第一个元素，就要使 k = 0，a[0] 就是偏移为 0 的位置，即第一个元素<br>如果数组从 1 开始计数，那我们寻址公式就变为：<br><code>a[k]_address = base_address + (k-1)*type_size</code><br>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令，降低效率。</p>
</blockquote>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>假设数组长度为 n，在数组中的第 k 个位置插入一个数据。我们需要将第 k～n 这部分的元素都顺序地往后挪一位，再把新增数据放在第 k 个位置。<br><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee95772.png" alt=""></p>
<blockquote>
<p>数组末尾插入元素：最好时间复杂度O(1)<br>数组开头插入元素：最坏时间复杂度O(n)<br>平均时间复杂度 (1+2+…n)/n=O(n)</p>
</blockquote>
<blockquote>
<p>改进方法：如果数组只用来存储数据，不要求有序，可以把第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置</p>
</blockquote>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据</p>
<blockquote>
<p>删除末尾数据：最好时间复杂度O(1)<br>删除开头数据：最坏时间复杂度O(n)<br>平均时间复杂度O(n)</p>
</blockquote>
<blockquote>
<p>改进方法：如果删除次数多，可以在每次删除时只进行逻辑删除，然后将多次删除操作集中在一起执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
</blockquote>
<h4 id="ArrayList相比数组的优点"><a href="#ArrayList相比数组的优点" class="headerlink" title="ArrayList相比数组的优点"></a>ArrayList相比数组的优点</h4><ul>
<li>ArrayList 封装了很多数组操作的细节，如数组插入、删除数据时需要搬移其他数据等</li>
<li>ArrayList 支持<strong>动态扩容</strong>。每次存储空间不够的时候，ArrayList 会将空间自动扩容为 1.5 倍大小。但是这一过程涉及内存申请和数据搬移，比较耗时。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</li>
</ul>
<h4 id="数组的应用场景"><a href="#数组的应用场景" class="headerlink" title="数组的应用场景"></a>数组的应用场景</h4><ul>
<li>ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而自动装箱、拆箱有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li>
<li>当要表示多维数组时，用数组往往会更加直观。</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表与数组不同，不需要一块连续的内存空间，它可以通过“指针”将一组零散的内存块串联起来使用，每个内存块称为一个结点。</p>
<p><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee9577b.png" alt=""></p>
<p>链表的结构很多，这里重点介绍三种最常见的：单链表、循环链表、双向链表。</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表的结点包含存储数据 data 和一个<strong>后继指针</strong> next ，next 指向下一个结点地址。<br><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee95780.png" alt=""><br>其中<br><strong>头结点</strong>是第一个结点，用来记录链表的首地址，通过它可以遍历得到整条链表<br><strong>尾结点</strong>是链表上最后一个结点，指针指向 NULL</p>
<h5 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h5><p>在链表中插入和删除不需要像数组那样搬移数据，而是改变相邻结点的指针就行了，时间复杂度为O(1)，如图所示<br><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee95782.png" alt=""></p>
<h5 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h5><p>链表中的数据在内存中时零散的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。需要 O(n) 的时间复杂度。</p>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表是一种特殊的单链表，与单链表的区别是<strong>尾结点指针指向链表的头结点</strong>。从图中看出，循环链表像个环一样首尾相连。<br><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee95785.png" alt=""><br>不难看出，循环链表的特点是从链尾到链头比较方便。当我们要解决问题的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题，代码会简洁很多。</p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br><img src="https://pic.imgdb.cn/item/5ee8c5a02cb53f50fee95788.png" alt=""></p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<p>双向链表可以在 O(1) 时间复杂度下找到前驱结点，所以双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>分为两种情况：</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点：不管是单链表还是双向链表，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点。总时间复杂度均为 O(n)。</li>
<li>删除给定指针指向的结点：已知要删除的结点，但是删除某个结点 b 需要知道其前驱结点，而单链表只能从头结点开始遍历链表，直到 a-&gt;next=b，说明 a 是 b 的前驱结点。但是双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要 O(1) 的时间复杂。</li>
</ul>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>与删除同理，如果要在链表的某个结点前插入一个结点，双向链表的时间复杂度是O(1)，而单链表需要 O(n) 的时间复杂度。</p>
<p>实际的软件开发中，虽然双向链表比较费内存，但还是比单链表的应用更加广泛的原因，这运用的是用空间换时间的设计思想。当内存空间充足的时候，为了追求代码的执行速度，就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反就要用时间换空间的设计思路。</p>
<h4 id="经典例题：基于链表实现-LRU-缓存淘汰算法"><a href="#经典例题：基于链表实现-LRU-缓存淘汰算法" class="headerlink" title="经典例题：基于链表实现 LRU 缓存淘汰算法"></a>经典例题：基于链表实现 LRU 缓存淘汰算法</h4><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<ol>
<li><p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p>
</li>
<li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p>
</li>
</ol>
<ul>
<li><p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p>
</li>
<li><p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</p>
</li>
</ul>
<p>不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p>
<h4 id="编写链表代码的技巧"><a href="#编写链表代码的技巧" class="headerlink" title="编写链表代码的技巧"></a>编写链表代码的技巧</h4><ol>
<li><p>留意边界条件处理：编写过程和编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
</li>
<li><p>举例法、画图法：对于稍微复杂的链表操作，很容易绕晕。写代码时可以找一个具体的例子，画在纸上，这样就会感觉到思路清晰很多。</p>
</li>
<li><p>多写多练：多刷leetcode链表代码</p>
</li>
</ol>
<h3 id="链表-vs-数组"><a href="#链表-vs-数组" class="headerlink" title="链表 vs 数组"></a>链表 vs 数组</h3><ul>
<li>数组简单易用，在实现上使用的是连续的内存空间，可以根据下标随机访问，所以访问效率更高，时间复杂度为O(1);但是插入删除需要挪动大量数据，时间复杂度为O(n)。而链表在内存中并不是连续存储，当随机访问一个结点时，要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。需要 O(n) 的时间复杂度。</li>
<li>数组大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。<blockquote>
<p>ArrayList也可以支持动态扩容,当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p>
</blockquote>
</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>栈</strong>是一种“操作受限”的线性表，只允许在一端插入和删除数据，这一端被称为栈顶，另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，从一个栈删除元素又称作出栈或退栈。类似于叠盘子，进栈等同于往最上面叠一个盘子，出栈等同于从顶上拿走一个盘子。</p>
<p>“先进后出”是栈的特征之一。</p>
<p>栈用数组实现叫做<strong>顺序栈</strong>，用链表实现叫做<strong>链式栈</strong>。</p>
<h4 id="实现一个顺序栈"><a href="#实现一个顺序栈" class="headerlink" title="实现一个顺序栈"></a>实现一个顺序栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于数组实现的顺序栈</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line">  private int[] items;  &#x2F;&#x2F; 数组</span><br><span class="line">  private int count;       &#x2F;&#x2F; 栈中元素个数</span><br><span class="line">  private int n;           &#x2F;&#x2F; 栈的大小</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 初始化数组，申请一个大小为 n 的数组空间</span><br><span class="line">  public ArrayStack(int n) &#123;</span><br><span class="line">    this.items &#x3D; new int[n];</span><br><span class="line">    this.n &#x3D; n;</span><br><span class="line">    this.count &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 入栈操作</span><br><span class="line">  public boolean push(int item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数组空间不够了，直接返回 false，入栈失败。</span><br><span class="line">    if (count &#x3D;&#x3D; n) return false;</span><br><span class="line">    &#x2F;&#x2F; 将 item 放到下标为 count 的位置，并且 count 加一</span><br><span class="line">    items[count] &#x3D; item;</span><br><span class="line">    ++count;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 出栈操作</span><br><span class="line">  public int pop() &#123;</span><br><span class="line">    &#x2F;&#x2F; 栈为空，则直接返回 null</span><br><span class="line">    if (count &#x3D;&#x3D; 0) return null;</span><br><span class="line">    &#x2F;&#x2F; 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span><br><span class="line">    int tmp &#x3D; items[count-1];</span><br><span class="line">    --count;</span><br><span class="line">    return tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个链式栈"><a href="#实现一个链式栈" class="headerlink" title="实现一个链式栈"></a>实现一个链式栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListStack &#123;</span><br><span class="line">  private Node top &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void push(int value) &#123;</span><br><span class="line">    Node newNode &#x3D; new Node(value, null);</span><br><span class="line">    &#x2F;&#x2F; 判断是否栈空</span><br><span class="line">    if (top &#x3D;&#x3D; null) &#123;</span><br><span class="line">      top &#x3D; newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      newNode.next &#x3D; top;</span><br><span class="line">      top &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * -1表示栈中没有数据。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public int pop() &#123;</span><br><span class="line">    if (top &#x3D;&#x3D; null) return -1;</span><br><span class="line">    int value &#x3D; top.data;</span><br><span class="line">    top &#x3D; top.next;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printAll() &#123;</span><br><span class="line">    Node p &#x3D; top;</span><br><span class="line">    while (p !&#x3D; null) &#123;</span><br><span class="line">      System.out.print(p.data + &quot; &quot;);</span><br><span class="line">      p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(int data, Node next) &#123;</span><br><span class="line">      this.data &#x3D; data;</span><br><span class="line">      this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData() &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。<br>在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>，这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p>
</blockquote>
<h4 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h4><p>要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p>
<ol>
<li>栈在函数调用中的应用（函数调用栈）<br>操作系统给每个线程分配了一块独立的内存空间，即java虚拟机栈，虚拟机栈描述的是java方法执行的内存模型。每个 Java 方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接，方法出口等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int a &#x3D; 1; </span><br><span class="line">   int ret &#x3D; 0;</span><br><span class="line">   int res &#x3D; 0;</span><br><span class="line">   ret &#x3D; add(3, 5);</span><br><span class="line">   res &#x3D; a + ret;</span><br><span class="line">   printf(&quot;%d&quot;, res);</span><br><span class="line">   reuturn 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">   int sum &#x3D; 0;</span><br><span class="line">   sum &#x3D; x + y;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/5ee8c5a12cb53f50fee9578c.png" alt=""></p>
<ol start="2">
<li><p>栈在表达式求值中的应用（来实现表达式求值）<br>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。<br>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。下图是<strong>3+5*8-6</strong>的演示过程。<br><img src="https://pic.imgdb.cn/item/5ee8c5a12cb53f50fee9578f.png" alt=""></p>
</li>
<li><p>栈在括号匹配中的应用(检查表达式中的括号是否匹配)<br>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式</p>
</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列也是一种操作受限的线性表数据结构。先进先出，是队列的最大特点。<br><img src="https://pic.imgdb.cn/item/5ee8c5a12cb53f50fee95791.png" alt=""><br>最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现<br><img src="https://pic.imgdb.cn/item/5ee8c5a12cb53f50fee95794.png" alt=""></p>
<h4 id="实现一个顺序队列"><a href="#实现一个顺序队列" class="headerlink" title="实现一个顺序队列"></a>实现一个顺序队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayQueue &#123;</span><br><span class="line">    &#x2F;&#x2F; 数组：items，数组大小：n</span><br><span class="line">    private int[] items;</span><br><span class="line">    private int n &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; head 表示队头下标，tail 表示队尾元素下一位</span><br><span class="line">    private int head &#x3D; 0;</span><br><span class="line">    private int tail &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 申请一个大小为 capacity 的数组</span><br><span class="line">    public ArrayQueue(int n)&#123;</span><br><span class="line">        this.items &#x3D; new int[n];</span><br><span class="line">        this.n &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 入队</span><br><span class="line">    public boolean enqueue(int item)&#123;</span><br><span class="line">        if(n &#x3D;&#x3D; tail)&#123;</span><br><span class="line">            if(head &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; head; i &lt; tail; i++) &#123;</span><br><span class="line">                items[i-head] &#x3D; items[i];</span><br><span class="line">            &#125;</span><br><span class="line">            tail -&#x3D; head;</span><br><span class="line">            head &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail++] &#x3D; item;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;出队</span><br><span class="line">    public Integer dequeue()&#123;</span><br><span class="line">        if(head &#x3D;&#x3D; tail)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp &#x3D; items[head++];</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个链式队列"><a href="#实现一个链式队列" class="headerlink" title="实现一个链式队列"></a>实现一个链式队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListQueue &#123;</span><br><span class="line">    private Node head;</span><br><span class="line">    private Node tail;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public LinkedListQueue()&#123;</span><br><span class="line">        head &#x3D; new Node();</span><br><span class="line">        tail &#x3D; head;</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean enqueue(int val)&#123;</span><br><span class="line">        Node tmp &#x3D; new Node(val);</span><br><span class="line">        if(head.val &#x3D;&#x3D; null)&#123;</span><br><span class="line">            head &#x3D; tmp;</span><br><span class="line">            tail &#x3D; tmp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            tail.next &#x3D; new Node(val);</span><br><span class="line">            tail &#x3D; tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer dequeue()&#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp &#x3D; (int) head.val;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">        size--;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Node&lt;E&gt;&#123;</span><br><span class="line">    E val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(E val, Node next)&#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(E val)&#123;</span><br><span class="line">        this(val, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node()&#123;</span><br><span class="line">        this(null, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>用数组实现队列时，在 tail==n 时，会有数据搬移操作，这样入队操作性能就会受到影响。循环队列能够有效避免数据搬移。将队列首尾相连，形成一个环，如图所示。<br><img src="https://pic.imgdb.cn/item/5ee8c5a12cb53f50fee95797.png" alt=""><br>head指向队首位置<br>tail指向队尾元素的下一位<br>队空判定条件：head == tail<br>队满判定条件：(tail+1)%n==head</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CircularQueue &#123;</span><br><span class="line">    private int[] items;</span><br><span class="line">    private int n;</span><br><span class="line">    private int head &#x3D; 0;</span><br><span class="line">    private int tail &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public CircularQueue(int n)&#123;</span><br><span class="line">        this.items &#x3D; new int[n];</span><br><span class="line">        this.n &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;入队</span><br><span class="line">    public boolean enqueue(int item)&#123;</span><br><span class="line">        if((tail+1)%n &#x3D;&#x3D; head)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail] &#x3D; item;</span><br><span class="line">        tail &#x3D; (tail+1)%n;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;出队</span><br><span class="line">    public Integer dequeue()&#123;</span><br><span class="line">        if(head &#x3D;&#x3D; tail)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp &#x3D; items[head];</span><br><span class="line">        head &#x3D; (head+1)%n;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞队列与并发队列"><a href="#阻塞队列与并发队列" class="headerlink" title="阻塞队列与并发队列"></a>阻塞队列与并发队列</h4><p>队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！<br><img src="https://pic.imgdb.cn/item/5ee8c5a12cb53f50fee9579b.png" alt=""><br>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p>
</br>

<p>以上就是数据结构与算法数组、链表、栈以及队列的相关内容啦，喜欢的小伙伴可以关注收藏我的<a href="https://rabbitgy.github.io/" target="_blank" rel="noopener">私人博客</a>，这里有你想要的一切哦，兄弟，还等啥呢？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Hexo-GitHub双拳搭建私人博客"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/15/Hexo-GitHub%E5%8F%8C%E6%8B%B3%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/"
    >Hexo+GitHub双拳搭建私人博客</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/15/Hexo-GitHub%E5%8F%8C%E6%8B%B3%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time datetime="2020-06-15T04:22:50.000Z" itemprop="datePublished">2020-06-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/">博客</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="为什么要搭建私人博客？"><a href="#为什么要搭建私人博客？" class="headerlink" title="为什么要搭建私人博客？"></a>为什么要搭建私人博客？</h3><ul>
<li>阶段性总结、消化所学的知识，每天比昨天的自己进步一点点</li>
<li>与小伙伴交流技术，碰撞思维的火花</li>
<li>现成博客网站广告多，阅读体验不佳</li>
<li>可diy私人博客的一切</li>
</ul> 
      <a class="article-more-link" href="/2020/06/15/Hexo-GitHub%E5%8F%8C%E6%8B%B3%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> RabbitGY
      </li>
    </ul>
    <!--<ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    -->
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/gy.png" alt="RabbitGY"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯Mojito吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>